# OAuth with PKCE

This document describes the OAuth Authorization Code flow with PKCE (Proof Key for Code Exchange) implementation in Liminal Type Chat.

## Overview

PKCE (pronounced "pixy") is an extension to the OAuth 2.0 Authorization Code flow that prevents authorization code interception attacks. It is particularly important for:

- Mobile applications
- Single-page applications
- Native desktop applications
- Any client that cannot securely store a client secret

## How PKCE Works

PKCE adds two additional parameters to the OAuth flow:

1. **Code Verifier**: A cryptographically random string generated by the client
2. **Code Challenge**: A transformed version of the code verifier

### PKCE Flow

The OAuth Authorization Code flow with PKCE works as follows:

1. **Client prepares**:
   - Generates a cryptographically random code verifier
   - Creates a code challenge by applying a transformation to the code verifier
   - Stores the code verifier securely for later use

2. **Authorization request**:
   - Client redirects the user to the authorization server with the authorization request
   - The request includes the code challenge and the code challenge method (e.g., `S256`)

3. **User authenticates**:
   - User authenticates with the authorization server (e.g., GitHub)
   - Approves the requested permissions

4. **Authorization code is returned**:
   - Authorization server redirects to the client's redirect URI
   - Includes the authorization code and state parameter

5. **Token request with verification**:
   - Client exchanges the authorization code for tokens
   - Includes the original code verifier with the token request
   - Authorization server verifies the code verifier by transforming it and comparing it to the original code challenge
   - If they match, tokens are issued; if not, the request is rejected

## Implementation in Liminal Type Chat

### PKCE Utilities

The `PkceUtils.ts` module provides the following functions:

- `generateCodeVerifier()`: Generates a cryptographically random code verifier
- `generateCodeChallenge()`: Creates a code challenge from a code verifier using the specified method
- `verifyCodeChallenge()`: Verifies that a code challenge matches a code verifier

### Storage for PKCE Data

The `PkceStorage.ts` module provides:

- In-memory storage for PKCE authorization session data
- Management of state, code verifiers, and redirect URIs
- Automatic expiration of old authorization sessions

### OAuth Provider Interface with PKCE Support

The `IOAuthProvider` interface has been extended to support PKCE:

- Added a `supportsPkce` property to indicate PKCE support
- Extended `getAuthorizationUrl()` to accept PKCE options
- Extended `exchangeCodeForToken()` to accept a code verifier

### GitHub OAuth Provider with PKCE Support

The GitHub OAuth provider now implements the PKCE flow:

- Indicates PKCE support via the `supportsPkce` property
- Adds code challenge and method to authorization URLs when PKCE is used
- Includes the code verifier in token exchange requests

### Authentication Routes with PKCE

The authentication routes have been updated to support PKCE:

- Automatically enables PKCE for supporting providers
- Allows clients to opt out of PKCE if needed
- Stores and manages PKCE session data
- Verifies PKCE parameters during token exchange
- Includes a maintenance endpoint to clean up expired sessions

## Using PKCE in Your Client

### Enabling PKCE (Default)

PKCE is automatically enabled for OAuth providers that support it. When requesting an authorization URL:

```typescript
// Client-side code
const response = await fetch('/auth/oauth/github/authorize', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    redirectUri: 'https://myapp.example.com/callback'
  })
});

const { authUrl, state, pkceEnabled } = await response.json();

// Store state for later verification
localStorage.setItem('oauth_state', state);

// Redirect user to authorization URL
window.location.href = authUrl;
```

### Disabling PKCE (Optional)

If needed, PKCE can be disabled by setting `usePkce: false`:

```typescript
const response = await fetch('/auth/oauth/github/authorize', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    redirectUri: 'https://myapp.example.com/callback',
    usePkce: false
  })
});
```

### Exchanging the Authorization Code

After the user is redirected back to your application, exchange the code for tokens:

```typescript
// Get code from URL query parameters
const urlParams = new URLSearchParams(window.location.search);
const code = urlParams.get('code');
const returnedState = urlParams.get('state');

// Verify state matches what we stored
const storedState = localStorage.getItem('oauth_state');
if (returnedState !== storedState) {
  throw new Error('OAuth state mismatch - possible CSRF attack');
}

// Exchange code for token
const response = await fetch('/auth/oauth/github/token', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    code,
    redirectUri: 'https://myapp.example.com/callback',
    state: returnedState
  })
});

const { token, user } = await response.json();

// Store token for API requests
localStorage.setItem('auth_token', token);
```

## Security Benefits

PKCE enhances security in the following ways:

1. **Protection against authorization code interception**: If an attacker intercepts the authorization code, they cannot exchange it for tokens without the code verifier.

2. **Mitigation of CSRF attacks**: The state parameter and PKCE together provide strong protection against cross-site request forgery.

3. **No client secret needed**: Public clients can use OAuth securely without storing a client secret.

4. **Protection against code injection**: For redirect-based flows, PKCE helps protect against authorization code injection.

## References

- [RFC 7636: Proof Key for Code Exchange](https://tools.ietf.org/html/rfc7636)
- [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/html/draft-ietf-oauth-security-topics)
- [OAuth 2.0 for Browser-Based Apps](https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps)